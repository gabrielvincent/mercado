package stats

import (
	l "mercado/app/views/layouts"
	stringsUtils "mercado/utils/strings"
	expense "mercado/app/models/expense"
	"time"
	"strconv"
	"github.com/goodsign/monday"
)

func daysInMonth(year, month int) int {
	lastDay := time.Date(year, time.Month(month)+1, 0, 0, 0, 0, 0, time.UTC).Day()
	return lastDay
}

func getCurrentDayOfMonth() int {
	now := time.Now()
	return now.Day()
}

templ Semibold() {
	<span class="font-semibold">
		{ children... }
	</span>
}

templ Currency(value int) {
	@Semibold() {
		{ stringsUtils.FormatCurrency(value) }
	}
}

templ PreviousMonthCompare(info *expense.PreviousMonthCompareInfo) {
	<span>A essa altura, no m√™s passado, voc√™ tinha gastado</span>
	{ " " }@Currency(info.Total) {
	"."
}
}

templ Sessions(expenses []expense.Expense, info *expense.PreviousMonthCompareInfo, day int) {
	Voc√™ j√° foi ao mercado
	{ " " }@Semibold() {
	{  strconv.Itoa(len(expenses)) }
}
	{ " " }
	vezes esse m√™s.
	if info != nil {
		{ " " }No m√™s passado, at√© o dia <span class="font-semibold">{ strconv.Itoa(day) }</span>, tinham sido <span class="font-semibold">{ strconv.Itoa(info.Sessions) }</span> idas ao mercado.
	}
}

var isFirst = true

script loadDeferred(id string) {
    loadDeferredComponent(id)
}

templ DeferredComponent(id string, completed bool, children ...any) {
	<div
		data-defer-id={ id }
		data-defer-completed={ strconv.FormatBool(completed) }
	>
		{ children... }
	</div>
	@loadDeferred(id)
}

templ GroceryStoresRanking(ranking []expense.GroceryStoresRankingItem) {
	@DeferredComponent("grocery-stores-ranking", true) {
		O mercado que voc√™ mais visitou foi o{ " " }
		@Semibold() {
			{ ranking[0].GroceryStore }.
		}
		Voc√™ l√° esteve{ " " }
		@Semibold() {
			{ strconv.Itoa(ranking[0].Sessions) }
		}
		{ " " }vezes. O ranking √© esse aqui:
		<div
			class="mt-2 p-3 bg-gray-100 rounded-lg"
		>
			for i, item := range ranking {
				<div class="flex items-center gap-2">
					<span>
						switch i {
							case 0:
								ü•á
							case 1:
								ü•à
							case 2:
								ü•â
							case 3:
								4Ô∏è‚É£
							case 4:
								5Ô∏è‚É£
							case 5:
								6Ô∏è‚É£
							case 6:
								7Ô∏è‚É£
							case 7:
								8Ô∏è‚É£
							case 8:
								9Ô∏è‚É£
							case 9:
								üîü
							default:
								{ "- " }
						}
					</span>
					<div class="w-full flex items-center justify-between">
						<span
							class={ "font-semibold",
                            templ.KV("text-amber-400", i == 0),
                            templ.KV("text-stone-400", i == 1),
                            templ.KV("text-orange-400", i == 2) }
						>
							{ item.GroceryStore }
						</span>
						<span>
							({ strconv.Itoa(item.Sessions) }
							if item.Sessions > 1 {
								{ " " }visitas)
							} else {
								{ " " }visita)
							}
						</span>
					</div>
				</div>
			}
		</div>
	}
}

func formatLocaleDate(date time.Time) string {
	return monday.Format(date, "January 2006", monday.LocalePtBR)
}

type PreviousMonthProps struct {
	date              time.Time
	totalSpent        int
	totalSessions     int
	avgSpentBySession float64
	avgSpentByDay     float64
	avgSessionsByDay  float64
	ranking           []expense.GroceryStoresRankingItem
}

templ RenderPreviousMonth(props PreviousMonthProps) {
	@l.Layout() {
		<div class="p-4">
			<h2>{ formatLocaleDate(props.date) }</h2>
			<p>
				Total Gasto:{ " " }
				@Currency(props.totalSpent)
			</p>
			<p>
				M√©dia de gastos por ida ao mercado:{ " " }
				@Currency(int(props.avgSpentBySession))
			</p>
			<p>
				M√©dia de gastos por dia:{ " " }
				@Currency(int(props.avgSpentByDay))
			</p>
			<p>
				Total de idas ao mercado:{ " " }
				@Semibold() {
					{ strconv.Itoa(props.totalSessions) }
				}
			</p>
			<p>
				M√©dia de idas por dia:{ " " }
				@Semibold() {
					{ strconv.Itoa(int(props.avgSessionsByDay)) }
				}
			</p>
			@GroceryStoresRanking(props.ranking)
		</div>
	}
}

func PreviousMonth(date time.Time, expenses []expense.Expense, ranking []expense.GroceryStoresRankingItem) templ.Component {
	totalSpent := expense.CalcTotal(expenses)
	totalSessions := len(expenses)
	numberOfDays := daysInMonth(date.Year(), int(date.Month()))

	props := PreviousMonthProps{
		date:              date,
		totalSpent:        totalSpent,
		totalSessions:     totalSessions,
		avgSpentBySession: float64(totalSpent) / float64(totalSessions),
		avgSpentByDay:     float64(totalSpent) / float64(numberOfDays),
		avgSessionsByDay:  float64(totalSessions) / float64(numberOfDays),
		ranking:           ranking,
	}
	return RenderPreviousMonth(props)
}

templ RenderIndex(
	date time.Time,
	expenses []expense.Expense,
	prevMonthCompareInfo *expense.PreviousMonthCompareInfo,
	ranking []expense.GroceryStoresRankingItem,
) {
	@l.Layout() {
		<div class="p-4">
			<h1>{ formatLocaleDate(date) }</h1>
			<h1 class="font-bold text-lg mb-4">Ol√°, { ctx.Value("name").(string) },</h1>
			<p>
				hoje √© o 
				<span class="font-semibold">{ strconv.Itoa(getCurrentDayOfMonth()) }¬∫</span>
				dia do m√™s e voc√™ j√° gastou
				<span class="font-semibold">
					@Currency(expense.CalcTotal(expenses))
				</span>.
				At√© agora, voc√™ gastou em m√©dia 
				@Currency(int(expense.CalcAvg(expenses)))
				{ " " }a cada ida ao mercado (foram j√° <span class="font-semibold">{ strconv.Itoa(len(expenses)) }</span>
				if len(expenses) > 1 {
					vezes,
				} else {
					vez,
				}
				uma m√©dia de
				<span class="font-semibold">{ strconv.FormatFloat(float64(len(expenses)) / float64(getCurrentDayOfMonth()) , 'f', 2, 64) }</span>
				idas ao mercado por dia, o que d√° uma m√©dia de
				<span class="font-semibold">
					@Currency(int(float64(expense.CalcTotal(expenses)) / float64(getCurrentDayOfMonth())))
				</span> gastos por dia!)
				Voc√™ acha bonita uma coisa dessas?
			</p>
			if prevMonthCompareInfo != nil {
				<p class="mt-4">
					@PreviousMonthCompare(prevMonthCompareInfo)
				</p>
			}
			<p class="mt-4">
				@Sessions(expenses, prevMonthCompareInfo, getCurrentDayOfMonth())
			</p>
			<p class="mt-4">
				@GroceryStoresRanking(ranking)
			</p>
		</div>
	}
}

func Index(date time.Time, expenses []expense.Expense, prevMonthCompareInfo *expense.PreviousMonthCompareInfo, ranking []expense.GroceryStoresRankingItem) templ.Component {
	currentDate := time.Now()

	if currentDate.Year() == date.Year() && currentDate.Month() == date.Month() {
		return RenderIndex(date, expenses, prevMonthCompareInfo, ranking)
	}

	return PreviousMonth(date, expenses, ranking)
}
